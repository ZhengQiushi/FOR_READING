## 老代码阅读

### main

- 线程初始化，开摄像头显示辅助程序

- 开启attack线程组，各线程对attack、windmill初始化，通过wait_and_get可以阻塞摄像头，使各线程分别领取任务并分别执行，通过getWorkMode得到工作模式

  RM_WINDMILL开头的模式进入i=0的线程跑风车，然后根据具体的工作模式决定风车模式

  RM_AUTO_ATTACK模式跑自瞄代码，主线程显示图像（根据时间戳排序）

- 通讯器不断获得程序进程信息并发送



### attack

- 初始化参数，清除上次处理的数据，根据最新的打击历史的尺寸和相对帧编号判断是否启用ROI

- m_preDetect

  进行预检测，通过hsv颜色阈值筛选，寻找边缘，通过面积、长宽比、灯条长度和倾斜角进行筛选，后对灯条按x大小排序，逐个匹配灯条筛选装甲板，扩展灯条区域，传回m_preTargets

  （_light参数中使用线段参数而并非矩形框参数来表示灯条，减少了矩形框宽度对装甲板的影响）

- 将预检测获得的装甲板送入tensorflow分类器，分类判断好坏结果后传回m_targets

- 处理多线程新旧数据，如果已有更新的一帧发送，放弃当前结果（互斥锁）

- 调用communicator中的getGlobalAngle获得最新的云台全局欧拉角，base中的calcWorldParams计算云台坐标系，在m_match中匹配目标（两种情况：之前没选择过打击目标/选择过，找得到一样的目标），进行预测和坐标修正（射击模式下进行卡尔曼滤波参数修正），修正弹道并计算欧拉角，射击策略，通过PID修正，最后将结果发给电控，返回bool类型



### windmill

- 与自瞄类似，先清空上次的处理数据，获得时间戳

- hsv颜色二值化处理，并进行尺寸等的预处理

- 框选风车装甲板（triangular模式可通过角度与时间历史列表计算出风车旋转速度），返回装甲板长度和y值

- solvepnp计算风车的pitch和yaw角度值和x，y，z坐标

  装甲板形状比较奇特且有angle历史列表可以不用分类器（？）

- 返回bool类型



### communicator

- 开始接收线程startReceiveService

  三个主要信息：击打状态、大小标识符、工作模式

  接收yaw，pitch

- crc校验：一个crc码能被生成多项式整除，接收方用同样生成多项式相除，若余数不为0，则说明某位出错

- 守护线程：如果串口未被打开且未停止，警告尝试打开和线程数，转移时间片设置尝试次数



### imageshow

#### ImageShowClient 线程绘图

- 绘制各种图像（如轮廓、目标、灯条等等） 图像显示

- update 更新本次处理的基础图像

- clock计时 计算两次相同name传入之间的耗时，有多个同名调用，取最远的两次

​      互斥锁输出，保证client间输出不被打断

#### ImageShowServer 主线程图像显示

- m_keyEvent处理用户的按键信息waitkey的返回值

- mainloop 利用imshow、line、键鼠操作等显示主图



### capture

录视频

- 辣鸡摄像头、大华摄像头和迈德威视摄像头的打开、连接、初始化、设置参数

- play 开始采集图像、接收数据、处理视频并保存

- wait_and_get 阻塞获得图像，保证线程安全