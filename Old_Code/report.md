# 各线程分析

* 主线程：初始化，之后变成图像显示线程。

* 通信线程：不断从电控接收yaw和pitch及工作模式，写入角度队列(`Communicator::StartReceiveService`)。

* 攻击线程：各线程竞争读取摄像头数据(`Capture::wait_and_get`)，分头进行处理(`Attack::m_preDetect`&`Attack::m_classify_single_tensor`)后，按时间戳竞争`AttackBase::s_mutex`写入全局状态并发送到电控。读取摄像头每帧的同时，若启用录制，则在录制进程空闲时加入新帧。发送消息到电控后，若图像显示进程空闲，则发送新图像。

* 图像显示线程：利用信号量`s_semaphore`等待攻击线程发送的图像，获得后显示图像，并处理键鼠交互(`ImageShowServer::mainloop`)。

* 录制进程：若启用录制且使用大华或者迈德威视摄像头，则启动摄像头后开启，等待录制视频信号量`DaHuaVision::m_semaphore`并保存(`DaHuaVision::run`)。

备注：

* 角度队列：可以据此读取非最新的状态，但是本程序中使用时都是使用最新的，估计是难以同步通信部分和摄像头的时间。

* 按时间戳竞争：各线程处理完当前结果后竞争spinlock，获得后放入时间戳，若以处理完的时间戳大于当前线程处理完的，则意味着其他线程后读取的帧已经处理结束，当前线程先读取的帧后才理完成，此时放弃当前线程的处理结果。

* 信号量：保证读取方每次读取时至少有一个数据已经被写入，且写入时读取方处于等待状态。本程序中，应用是作为一个不阻塞的互斥锁，使得攻击线程不因接收线程速度缓慢而阻塞，仅在接收方空闲时发送数据，否则直接忽略。

# 自瞄

每个攻击线程的死循环中，调用`communicator.getWorkMode()`（这函数里的switch case有啥意义）获取当前的工作状态，如果是`RM_AUTO_ATTACK`则为自瞄模式，否则是风车模式。

自瞄流程很标准，首先是清除上次处理的数据（所有的处理函数都不是纯函数，全部会修改对应的`Attack`类中的成员，~~函数式厨狂怒~~）。这里由于每个线程都有自己对应的`Attack`实例，没有竞争。

之后进行预处理，颜色阈值、膨胀、找边框、筛选灯条、枚举矩形对并筛选，非常经典。预处理的结果放入`m_pretargets`。

对于筛选出的每个目标，调用tensorflow进行分类，~~如果把攻击线程的多线程换成tensorflow的多线程，这程序将绝杀，延迟和流量双双优化，可惜换不得~~。分类器处理结果放入`m_targets`。

之后开始需要更改全局变量，按时间戳竞争`s_mutex`。

获得`s_mutex`后，在`m_match`中选择目标，并利用卡尔曼滤波优化，然后计算欧拉角（又是非纯函数），利用pid优化，最后是发给通信部分。 若成功找到目标，则函数返回true。

## 风车

风车的流程和自瞄类似，不过可能是目标比较明显，并没有使用炼丹。风车识别仅限第一个线程运行，不知道为什么。

# 显示图像

显示图像的方法定义在**include/imageshow.hpp**，分为`ImageShowClient`和`ImageShowServer`两部分，分别在攻击线程和图像显示线程中使用。

`ImageShowServer`中的`mailoop`即调用`imshow`和`waitkey`的通常的main函数，负责接收展示`ImageShowClient`发送来的图像。使用信号量指示当前是否空闲，即是否可以接收图像。

`ImageShowClient`实例全部存储于对应的`ImageShowServer`的`m_clients`变量中（不是每个线程单独存储的原因可能是为了多个线程更新时同个缓冲块互相打架，~~可能起到降低性能的作用~~），主要包括：

* `update`：更新本对象内部的图像。

* `show`：尝试发送图像给服务器（全局变量），若服务端忙碌则忽略。每个图像显示客户端都有对应的编号，且全局变量中为此开辟了对应数量的缓冲区，更新时，把当前客户端的图像复制到本客户端对应的缓冲区，并记录本客户端的编号。服务端届时根据编号读取对应缓冲区中的图像。

* `clock`：两次调用时名称配对，可以自动处理繁琐的计时任务。

* 一大堆绘图函数：用来本客户端对应的图像上画画。
